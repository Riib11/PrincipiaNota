\documentclass{article}

\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linktoc=all,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}
\usepackage{amsmath}
\usepackage{mathpazo}
\usepackage{textcomp}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{marginnote}
\usepackage{amssymb}

%===============================================================
%===============================================================
%===============================================================
%===============================================================
% COMMANDS

\newcommand{\definition}[1]{
	\vspace{10px}
	\noindent {[\sc Definition]} #1
	\vspace{10px}
}
\newcommand{\tbs}{\textbackslash}
\newcommand{\ttilde}{\textasciitilde}
\newcommand{\tasterisk}{\textasteriskcentered}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\p}{^\prime}

%===============================================================
%===============================================================
%===============================================================
%===============================================================
% TITLE PAGE

\title{Principia Nota}
\author{Henry Blanchette}
\date{}

%===============================================================
%===============================================================
%===============================================================
%===============================================================
% BEGIN DOCUMENT

\begin{document}
\maketitle
\tableofcontents

\newpage

\section{Introduction}

The point of this compilation is to record and formalize my notations. I am very intrigued by the aesthetics of code, where I mean code in the most general sense:

\definition{A \textbf{code} is a set of consistent and formal rules for recorded expression.}

Note that I didn't restrict code to only \textit{computer} code. I think that, although there are obvious and important distinctions between code meant to be read by humans and code meant to read by machines, the distinctions are merely superficial. In my taxonomy, I label \textit{Machine Language} the section for programming languages (usually written by humans) and machine/assembly-esque code.

There is a distinction between what I mean by \textit{code} and what I mean by \textit{language}. In fact, the term \textit{language} actually has a technical meaning in computer science.

\newpage

%===============================================================
%===============================================================
%===============================================================
%===============================================================
% Content
	
\section{Rich Text}

\subsubsection{Header}
\subsubsection{Plain}
\subsubsection{Italic}
\subsubsection{Bold}
\subsubsection{Bold and Italic}
\subsubsection{Underline}
\subsubsection{Math}
\subsubsection{Code}

\section{Archaic}

%===============================================================
%===============================================================
\section{Philosophy}

\subsection{Logic}
\subsubsection{Truth Table}
\subsubsection{Variable}

\subsection{Metaphysics}

\subsection{Epistemology}

\subsection{Ethics}


%===============================================================
%===============================================================
\section{Mathematics}

\subsection{Names}

\subsubsection{Greek}
\subsubsection{Latin}
\subsubsection{Diacratic}
\subsubsection{Special Symbol}
\subsubsection{Capitalization}
\subsubsection{Abbreviation}
\subsubsection{Length}
\subsubsection{Scale}

\subsection{Set Theory}

	Set Theory is one of the most fundamental theories in mathematics. As per this important role, it reserves some very iconic and widespread notation.

	\definition{A \textbf{set} is an collection of things. There is no necessary relation between the things. For things $s_1, s_2, \dots$ the set of just these things is denotes $\{ s_1, s_2, \dots \}$. A set with no things is denoted $\{\}$ or $\varnothing$.}

	Global-scope sets are usually named with capitalized, single letters. This easily leads to the elements of a globally-scoped set usually named with variants on the lower-case of that letter. For example, we could write $S = \{ s \}$, or $S = \{ s_1, s_2, \dots, s_n \}$. Note that a member of a set could also be a set. This naming convention stays consistent because of the ``globally-scoped'' aspect. By a \textit{globally-scoped} set name, I mean that the context of the name doesn't frequently refer to or make reference to the set's being a member of other sets.

	The kinds of things that can go into a given set are unrestricted. If $s$ is in $S$, then we write ``$s$ is a member of $S$'', ``$s$ is an element of $S$'', or with mathematical symbols,  \[ s \in S \]

	The symbol ``$\in$'' is derived from a standard ``$\epsilon$''. In \textit{Arithmetices prinicipia nova methodo exposita} Giuseppe Peano used ``$\epsilon$'' to abbreviate ``est'', which is latin for ``in'' (note that the text was entirely in latin). Later in Bertrand Russel's \textit{Principia Mathematica}, the same meaning was used but the printed ended up looking more like ``$\in$'', a intended to be a more modern-looking epsilon. The new symbol was adopted over time as distinct from ``$\epsilon$'' and delegated exclusively to meaning ``\dots is a member of the set \dots''.

	Dealings with sets also get their own notations. Symbols can be reflected across their y-axis to yield the symbol working in the opposite direction. For example, $A \subset B$ can be written as $B \supset A$. The most important set-related notations are
	\begin{tabular}{c|l}
		Symbol Instance & Description \\ \hline
		$a \in A$ &
			Set membership. $a$ is an element of $A$. \\
		$A \cup B$ &
			Set union. The set with all the elements of $A$ and all the elements of $B$. The symbol resembles a ``linking'' of the two sets, like a chain. \\
		$A \cap B$ &
			Set intersection. The set with all the elements of $A$ that are also elements of $B$. The symbol resembles a filtering of the two sets, like a sifting apparatus or funnel. \\
		$A \setminus B$ &
			Set difference. The set with all the elements of $A$ that are not elements of $B$. The symbol resembles a long and tilted minus sign. \\
		$A \subset B$ &
			Proper subset. The symbol is an alteration on the $\cup, \cap$, with the sideways tilt indicating that $A$ unioned with some other set would yield $B$. Specifically, $A \subset B$ usually implies that $A \neq B$. However, some take the convention of allowing $A = B$, in which case their is no technical difference between $A \subset B$ and $A \subseteq B$. The only difference is an emphasis on the possibility that $A = B$. \\
		$A \subseteq B$ &
			Included subset. The symbol is an alteration on $\subset$, adding half of a $=$ underneath to indicate the possibility of $A = B$. \\
		$A = B$ &
			Set equality. Sets are equal if and only if $A \subseteq B$ and $B \subseteq A.$ \\
		$\{ a \in A \mid a \text{ has property } P \} &
			Set definition idiom. This translates to ``the largest subset of $A$ in which every element has property $P$''. Note that $P$ is extremeley flexible. This notation for defining sets is extremeley useful and concise. Sometimes, the ``$\in A$'' to the left of ``\mid'' is not written and is eiher implied by ``P'' or assumed to be unrestricted to any particular set. \\
		$A \times B$
			Cartesian Product. Formally, $A \times B = \{ (a,b) \mid a \in A, b \in B \}$. $A \times B$ is pronounced ``the Cartesian cross-product of A and B,'' but the ``Cartesian'' adjective is implicit. The ``cross'' idea is to imagine that $A$ and $B$ are perpendicular axes, forming a cross, and yielding a grid where each point in the grid is labeled by an $(a,b)$ where $a \in A, b \in B$. This is the \textit{ordered pairs} cross the sets. An ordered pair written as $(a,b)$ which is a notation for $\{ a , \{a, b\}\}. The set construction indicates ordering by having the ``second'' element only appear in the set that is the second element of $(a,b)$. This set construction works well for ordered pairs, but it difficult to extend to the more generic \textit{n-tuple}. I will cover this later. \\
		$A / B$ &
			Set modulus. TODO \\
	\end{tabular}

	\begin{enumerate}
		\item $\cap$ 
	\end{enumerate}



\subsection{Measure Theory}

\subsection{Number Theory}

\subsection{Algebra}

\subsection{Analysis}

\subsection{Calculus}

\subsection{Graph Theory}

%===============================================================
%===============================================================
\section{Computarelogy}

\subsection{Binary}

	Binary is the base-2 number-representation format. The name ``binary'' comes from latin, \textit{binarius}, which means ``consisting of two''. Indeed, the symbols allowed in binary numbers is a \textit{binarius} set: $\{ 0, 1 \}$. Note that binary numbers don't have different \textit{values} from, from example, decimal numbers.  The convention for number-representation formats using the arabic numerals is that the value of each number increases from right to left. The rightmost repesents a number of $2^0$s, and for each slot $2^i$, the slot immediately to the left of it is $2^{i+1}$. You may abstractly think of a number in this kind of format as a string that stretches infinitely leftward from a rightmost origin, where each slot contains a numeral (in the case of binary, a $0$ or a $1$).

	\definition{A \textbf{bit} is a single $0$ or $1$, not necessarily interpreted in the context of representing a longer binary-formatted number.}

	In terms of notation, this abstract representation is inefficient because we most often represent numbers that require only a few slots, and be waste our time always considering the infite string of $0$s on the left-tail of each number-representation when we can represent all of those zeros consicely by not writing them at all. In general written notation, any zero that is the leftmost numeral in a number-representation may be removed with no interpretive effect.

	In the context of Computarelogy however, we sometimes do desire a few extra ``trailing'' zeros in our notation. This is because here, number values exist in the context of memory which is limited and usually pre-designated. If a value is 8-bits, then we want to write $000010$ rather than $10$ to indicate its 8-bit designation.

	\definition{An \textbf{n-bit} value is one that could only be one of $2^n$ possible values. This yields that is a bijection between each of these possible values and the numbers that can be represented using at maximum 8 slots in binary-form: $0, \dots, 2^n-1$}.

	Note that there is not just one binary format. Any bijection between n-bit values and the numbers $0, \dots, 2^n-1$.

\subsection{System}

\subsubsection{File System}
\subsubsection{}

\subsection{Pseudocode}


\subsection{Programming}

	This section focusses on the standards and conventions in computer programming. Many standards are enforced by programming languages and many conventions are not, and visa versa. Many conventions come in different flavors. However, for any particular program the convention choices are expected to be consistent across all of the code.

	I focus here on standards and conventions that are widespread across many languages and use cases, rather than language specific ones. However, as I reoterate later on, many language-specific constructions are inspired by broader coded themes.

\subsubsection{Special Symbol}
	Notation in programming languages often uses special symbols that resemble the look and function of mathematics ones, as well as adding a few new function to available ASCII characters. Some symbols have multiple distinct meanings, which are seperated by commas in the right column of the table below.

	Note that many programming languages devise their own special symbols or combinations of symbols that are language-specific and non-standard. This list records only the standard associations of the symbols across languages and academia. Additionally, many language-specific instances draw on these standards. For example, Python uses \code{//} for integer division, whereas it is standardly used to begin in-line comments. Why do languages differ is such odd, arbitrary ways? I don't know, however I may address this question later.

	\vspace{20px}
	
	\begin{tabular}{c|l}
		Symbol  & Meanings \\ \hline
		\code{+} 	&numeric addition, list join \\
		\code{-} 	&numeric subtraction, cabob-case \\
		\code{/} 	&numeric division \\
		\code{*} 	&numeric multiplication, type product, pointer type \\
		\code{\textasciicircum} &numeric power-of, bitwise XOR \\
		\code{\%}   &numeric modulo \\
		\code{\&}   	&bitwise AND, reference-of (pointers context) \\
		\code{|}    	&bitwise OR, case matching divider \\
		\code{\&\&} 	&boolean AND \\
		\code{||}	&boolean OR \\
		\code{!} 		&boolean NOT\\
		\texttildelow & bit inversion \\
		\code{<<}	&bits shift left \\
		\code{>>}	&bits shift right \\
		\code{<}		&numberic less than \\
		\code{<=}	&numeric less than or equal to\\
		\code{>}		&numeric greater than \\
		\code{>=} 	&numeric greater than or equal to\\
		\code{?}		&conditional ternary \\
		\code{=}		&value assignment, token equality \\
		\code{:=}	&value assignment \\
		\code{==}	&value equality \\
		\code{->}	&function type constructor \\
		\code{=>}	&anonymous function, ``maps to'' \\
		\code{,} 		&tuple \\
		\code{;}		&end of statement \\
		\code{\#}		&in-line comment begin \\
		\code{//} 		&in-line comment begin \\
		\code{/* */}   &multi-line comment block \\
		\textbackslash &begin escaped word \\
		\code{` '}	&a single of character type, unformatted string\\
		\code{" "}	&formatted string \\
		\code{( )} 	&function call with enclosed parameters, associative grouping \\
		\code{[ ]}	&indexing operator (comes after target, encloses index value)\\
		\code{\{ \}}	&block with new scope, object body \\
		\code{< >} &special parameters, type parameters \\
		\code{\$}		&associative divide \\
		\code{.}       &scope tree name divider
	\end{tabular}

\subsubsection{Naming}

	In programming almost everything needs a name. And every name carries with it much significance not encompasses solely by its pronunciation. The important factors to consider when judging a naming style are

	\begin{enumerate}
		\item \textbf{Readability} is how easily one can recognize the important characteristics of names.
		\item \textbf{Accuracy} is how closely names correspond to the full literal descriptions, including correct grammar and syntax, of their representees.
		\item \textbf{Brevity} is how efficiently name represent the relevant features of their representees.
	\end{enumerate}

	\paragraph{Casing.} When first reading someone's code, the first thing you will most likely notice is their style of casing. Casing is one of the easiest ways for source-code to convey abstract meaning tied to programming constructs. The dominant flavors of casing are

	\begin{enumerate}[label=\Alph*)]
		\item \textbf{Camel Case} has the first letter of each word (except, by default, the first word) in a name be upper case, whereas all other letters are lower case. For example, \code{thisIsAName}. As for the first word, its capitalization is delegated to contextual judgement. This case infamously has discontinuities with words that generally require capital letters and acronyms. For example, \code{XMLHttpRequest} is a commonly-used javascript function. Javascript standardly adheres to camel case, but this example demonstrates both an inconsistency with camel case and also with its interal casing. Compare it to \code{XmlHttpRequest} and \code{XMLHTTPRequest}. The truth is that none of them look particularly aesthetic. The problem is that XML and HTTP are both fully-capitalized acronyms, but together they cross a line of acceptable readability (especially as a function to be used as often as it is). So, the result trades accuracy for readability. In this case, the trade seems to be fine because as a common function people have gotten used to it without much of a problem. For conflicts like this in non-standard code however, instances of this problem become quite a pain on the eyes.

		\item \textbf{Snake Case} has each word in a name seperated by a \code{\_} character. For example, \code{this\_is\_a\_name}. Snake case is allowed in almost all languages, but is especially standard in C-like languages. Most C/C++ libraries make use of this casing. This casing is unparalled in its support for both readability and accuracy. Since words are completely seperated and \code{\_} is a (almost-)universally unrestricted character in names, snake case yields the most standard scheme for casing. All special-casings are also supported by this casing, like screaming-case, capital-case, and all-lower-case. However, snake case can also promote longer names with several words due to just the ease of it. In functional programming, snake case words can sometimes be hard to tell apart due to the \code{\_} being in the place of a space, for example \code{activate\_function on\_x with\_also\_y}. Note that, depending on your naming semantic-style, this can be a disadvantage \textit{or} an advantage.
		
		\item \textbf{Kebab Case} (aka Cobol Case) has each word in a name is seperated by a \code{-} character. For example, \code{this-is-a-name}. Famously, CSS standardizes and Agda requires kebab casing. The immediately-obvious drawback to this casing is the sacrifice of \code{-}. ``How could a language with kebab casing parse subtraction?'' you might wonder. Well, its definitely a problem that requires a solution. In CSS names are never occur nakely next to calcultion expressions, so kebab casing never yields any ambiguity. But this is special for CSS, as simply a styling language. For a more fully-featured language like Agda, kebab casing's tendrils influence and are infuenced by the very foundations of the language itself. In order to remove parsing-ambiguity or even reader-ambiguity, Agda requires that all names be seperated by spaces or other restricted characters. You could never write \code{a-b} to mean subtraction, you must write \code{a - b} or \code{(a)-(b)}. A reason for this enforcement is another feature of Agda: using the \code{\_} to ease infix notation. Rather than annotating an infix for an operator like \code{+}, Agda allows \code{\_+\_} where each \code{\_} represents and input around the use of the function.
	\end{enumerate}

	\paragraph{Capitalization.} These are the rules you use when deciding how to capitalize particular letters of a name. Different groups of letters in the word are used in seperate semantic spaces of convention.

	\begin{enumerate}
		\item \textbf{Proper Case} is where the first letter of each word in a name is upper-case. Capitalizing these letters signifies that this name is of a container- or structure-like thing. Specifically, the thing named either has children or parts, or is instanciable. Common use-cases are class names, module names, project names. The idea is that proper-cased names are of large, important objects that hold or control many smaller parts. Specifically in functional programming, this capitalization is used for the names of types. This choice is motivated by the facts that types and tokens are extremeley important to distinguish in a functional setting, as they are often used near name references. Additionally, the idea of a type being a sort of ``container'' of its tokens carries over from the more generic use of proper-casing. Overall, this casing is extremeley standard and useful, probably because it implictly rides on associations humans have with capitalized words.
		
		\item \textbf{Screaming Case} is where all letters in a name are upper-case, in the like of how a millenial (or younger) internet-forum participant indicates that they intend their words to be \textit{screamed} at the reciever. Screaming casing is almost universally adopted as a standard for naming either enumerated names or constant, global names. These are namse that do not change value and are defined usually in a global, static, or singleton-class context. This case conflicts heavily with camel casing. If restricted to very specific and consistent uses, this case is very useful and effectively seperates ``global'' and ``local'' sections of your code.

		\item \textbf{Lower Case} is where all letters in a name are lower-case. This casing is looked down upon because it sacrifices readability for seemingly no reason. Nevertheless, it makes its way into standard libraries across many languages. It is typically used for untility functions or temporary variable names. Note that one-word names do not count as lower-case unlese the scheme they are written in is consistently lower-case even in multi-worded names.
	\end{enumerate}

\subsubsection{Comment}


\subsection{Language}

	\definition{A \textbf{letter} is a member of an alphabet. Letters are denoted by single ASCII characters. $\sigma$ is associated with a generic letter.}

	\definition{An \textbf{alphabet} is a finite set of letters. $\Sigma$ is often used as the name of either a specific or generic alphabet.}

	\definition{A \textbf{string} is a $n$-tuple of letters, where $n$ is the length of the string.}

	\definition{A \textbf{language} is set of strings that all have letters in some alphabet $\Sigma$. $L$ is ogten used as the name f either a specific or generic language. $L(X)$ represents the language yielded by the $X$, where $X$ is an automata, grammar, or other language-yielding construct.}

\subsubsection{Context-Free Grammar}

	\definition{A context-free grammar (CFG) is a set of rules that yield a language (a context-free language (CFL)) with an alphabet $\Sigma$. Formally, a grammar $G$ is given by \[
		G = (S, \Sigma \cup \{ \epsilon \}, V, R)
	\] where $S$ is the start token, $\Sigma \cup \{ \epsilon \}$ is a set of terminals, $V$ is an alphabet of non-terminals, and $R$ is the set of rules. It is required that $(\Sigma \cup \{\epsilon\} \cap V = \varnothing)$.}

	The language is yielded by starting with $S$ and then applying each valid string of rules applications in $R^*$ (applying each string's rules consecutively, in order). In other words, a string is in the yielded language if it can be produced exactly by applying a valid string of rules, each rule consecutively, to $S$.

	\definition{A \textbf{token} is a letter in either $\Sigma$ or $V$.}

	\definition{If a token is \textbf{terminal}, then it cannot be manipulated by rule applications. If a terminal is produced by a rule application in a string, then it will persist till the string is completed. When a string contains only terminals, it is completed.}

	\definition{If a token is \textbf{non-terminal}, then it must be manipulated by rule applications. A string is not completed until all of the non-terminals have been transformed into terminals by rule appliations.}

	The rules follow a few conventions.
	\begin{enumerate}
		\item Capital letters reprents non-terminals.
		\item Rules are writted $A \rightarrow x$ where $A$ is a non-terminal and $x$ is a string of tokens. This represents the rule ``any A can be replaced with x''.
		\item The left-hand-side of each rule must be a single non-terminal. The right-hand-side of each rule must be a string of tokens.
		\item There must be at least one rule $S \rightarrow x$, where $x$ is a string of tokens.
		\item There must be at least one rule $A \rightarrow x$, where $A$ is a non-terminal and $x$ is a string of only terminals.
		\item For each terminal in $A \in V$, there must be at least one rule $A \rightarrow x$, where $x$ is a string of tokens.
		\item A subset of $R$ of the form $\{ A \rightarrow x_1, A \rightarrow x_2, \dots, A \rightarrow x_n \}$ can be written as $A \rightarrow x_1 \mid x_2 \mid \cdots \mid x_n$. $|$ are often used as dividers in case rules like this.
	\end{enumerate}

\subsubsection{Regular Expression}

	Regular expressions are a rare instance of practicality derived from this subfield of Computarelogy. A regular expression represents a set of strings. The academic standard for regular expressions is the simple grammar
	\[ \begin{array}{rll}
		S \rightarrow
			&\mid \epsilon & \text{empty string} \\
			&\mid \sigma_i \mid \cdots \mid \sigma_n & \text{letter of $\Sigma$} \\
			&\mid SS & \text{concatenation} \\
			&\mid (S \cup S) & \text{set union} \\
			&\mid (S)^* & \text{Kleene star: } \{ x_1 x_2 \cdots x_n \mid \forall i \geq 0, x_i \in S \}
	\end{array} \]
	Where $\Sigma = \{ \sigma_i, \dots, \sigma_n \}$ is the alphabet of the grammar. In addition to these standard rules, there are many other common rules:
	\[ \begin{array}{r|l}
		S+ 			&S^* \text{ while additionally requiring } i > 0 \\
		S?			&S^* \text{ while aditionally requiring } i = 0 \lor i = 1 \\
		S \mid S 	&\text{set union} \\
		\text{[} \sigma_1 \cdots \sigma_n \text{]}
					&\text{letter union:} \cup_{i=1}^n \sigma_i \\
		\text{[} \sigma_0-\sigma_1 \text{]}
					&\text{letters from $\sigma_0$ to $\sigma_1$ in the standard ordering of $\Sigma$} \\
		. 			&\text{anything except newline} \\
		\$ 			&\text{end of the string} \\
		
		
	\end{array} \]

\subsubsection{Automata}

\subsection{Computability}

\subsection{Complexity}

\subsection{Artificial Intelligence}


%===============================================================
%===============================================================
\section{Game Design}

%===============================================================
%===============================================================
\section{Physics}

%===============================================================
%===============================================================
\section{Economics}


\end{document}